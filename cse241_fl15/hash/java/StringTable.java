//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
public class StringTable {
    
    //
    // Create an empty table big enough to hold maxSize records.
    //
	public int max;
	public int count;
	static Record[] recordTable;
	int elements;
    public StringTable(int maxSize) 
    {
    	elements=maxSize;
    	max=maxSize*4;
    	recordTable=new Record[max];
    }
    
    
    //
    // Insert a Record r into the table.  Return true if
    // successful, false if the table is full.  You shouldn't ever
    // get two insertions with the same key value, but you may
    // simply return false if this happens.
    //
    public boolean insert(Record r) 
    { 
    	int k=toHashKey(r.key);
    	int i=0;
    	if(count==elements)
    		return false;
    	while(i<elements)
    	{
    		//int s=(baseHash(k)+i*stepHash(k))%max;
    		long sh=(long)stepHash(k);
    		long l=(long)i;
    		long n=l*sh;
    		long b=(long)baseHash(k);
    		long m=(long)max;
    		long q=(int) ((b+n)%m);
    		int s=(int)q;
    		if((recordTable[s]!=null)&&(recordTable[s].key.equals(r.key)==true))
    				return false;
    		if(recordTable[s]==null)
    		{
    				recordTable[s]=new Record(r.key);
    				recordTable[s].positions=r.positions;
    			    count++;
    			    //System.out.println(recordTable[s].key+"jjjjj");
    			    return true;
    		}
    		i++;
    	}
	return true; 
    }
    
    
    //
    // Delete a Record r from the table.  Note that you'll have to
    // find the record first unless you keep some extra information
    // in the Record structure.
    //
    public void remove(Record r) 
    {
    	int k=toHashKey(r.key);
    	int i=0;
    	while(i<elements){
    		long sh=(long)stepHash(k);
    		long l=(long)i;
    		long n=l*sh;
    		long b=(long)baseHash(k);
    		long m=(long)max;
    		long q=(int) ((b+n)%m);
    		int s=(int)q;
    		//int s=(baseHash(k)+i*stepHash(k))%max;
    		if(recordTable[s]!=null){
    		   if(r.key.equals(recordTable[s].key)==true){
    			  recordTable[s].positions=null;
    			  recordTable[s].key="Deleted";
    		   }
    		}
    		else{
    			return;
    		}
    		i++;
    	}
    }
    
    
    //
    // Find a record with a key matching the input.  Return the
    // record if it exists, or null if no matching record is found.
    //
    public Record find(String key) 
    {
    	int k=toHashKey(key);
    	int i=0;
    	while(i<elements){
    		long sh=(long)stepHash(k);
    		long l=(long)i;
    		long n=l*sh;
    		long b=(long)baseHash(k);
    		long m=(long)max;
    		long q=(int) ((b+n)%m);
    		int s=(int)q;
    		//System.out.println(n+"n");
    		//System.out.println(b+"b");
    		//System.out.println(key+"kkkkk");
    		//System.out.println(recordTable[s].key+"rrrrr");
    		if(recordTable[s]!=null){
    			//System.out.println(recordTable[s].key+"xxxxx");
    		   if(key.equals(recordTable[s].key)==true){
    			   //System.out.println(recordTable[s].key+"yyyyy");
    			  return recordTable[s];
    		}
    		}
    		else{
    			return null;
    		}
    		i++;
    	}
	return null; 
    }
    
    
    ///////////////////////////////////////////////////////////////////////
    
    
    // Convert a String key into an integer that serves as input to hash
    // functions.  This mapping is based on the idea of a linear-congruential
    // pesudorandom number generator, in which successive values r_i are 
    // generated by computing
    //    r_i = ( A * r_(i-1) + B ) mod M
    // A is a large prime number, while B is a small increment thrown in
    // so that we don't just compute successive powers of A mod M.
    //
    // We modify the above generator by perturbing each r_i, adding in
    // the ith character of the string and its offset, to alter the
    // pseudorandom sequence.
    //
    int toHashKey(String s)
    {
	int A = 1952786893;
	int B = 367257;
	int v = B;
	
	for (int j = 0; j < s.length(); j++)
	    {
		char c = s.charAt(j);
		v = A * (v + (int) c + j) + B;
	    }
	
	if (v < 0) v = -v;
	return v;
    }
    
    int baseHash(int hashKey)
    {
	// Fill in your own hash function here
    	int i;
    	double j=(double)hashKey;
    	double Max=(double)max;
    	double c=(Math.sqrt(5)-1)/2;
    	i=(int)Math.floor((Max*((j*c)%1)));
	    return i;
    }
    
    int stepHash(int hashKey)
    {
    	int i;
    	double j=(double)hashKey;
    	double Max=(double)max;
    	double c=(Math.sqrt(5)-1)/2;
    	i=1+(int)Math.floor(((Max-2)*((j*c)%1)));
	// Fill in your own hash function here
    	
	return i;
    }
}